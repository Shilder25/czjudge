```
// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// server/ai-service.ts
import OpenAI from "openai";
import Anthropic from "@anthropic-ai/sdk";

// server/emotion-analyzer.ts
var emotionKeywords = {
  celebrating: [\
    "congratulations",\
    "great job",\
    "well done",\
    "excellent",\
    "amazing",\
    "fantastic",\
    "wonderful",\
    "awesome",\
    "perfect",\
    "brilliant",\
    "impressive",\
    "outstanding",\
    "success",\
    "achievement",\
    "celebrate",\
    "hooray",\
    "yay",\
    "bravo",\
    "superb",\
    "\u{1F389}",\
    "\u{1F38A}",\
    "\u2728",\
    "\u{1F31F}",\
    "\u2B50",\
    "\u{1F3C6}",\
    "\u{1F44F}",\
    "good job",\
    "nice work",\
    "proud"\
  ],
  thinking: [\
    "let me explain",\
    "think about",\
    "consider this",\
    "ponder",\
    "analyze",\
    "understand",\
    "concept",\
    "theory",\
    "principle",\
    "reason",\
    "because",\
    "therefore",\
    "complex",\
    "intricate",\
    "detailed",\
    "specifically",\
    "let's explore",\
    "imagine",\
    "suppose",\
    "hypothesis",\
    "question"\
  ],
  angry: [\
    "careful",\
    "watch out",\
    "warning",\
    "danger",\
    "oops",\
    "mistake",\
    "error",\
    "incorrect",\
    "wrong",\
    "avoid",\
    "don't",\
    "shouldn't",\
    "risky",\
    "concern",\
    "worried",\
    "caution",\
    "alert",\
    "attention",\
    "important",\
    "critical",\
    "serious",\
    "issue",\
    "problem",\
    "\u26A0\uFE0F",\
    "\u2757",\
    "\u274C"\
  ]
};
function analyzeEmotion(text) {
  const lowerText = text.toLowerCase();
  const scores = {
    celebrating: 0,
    thinking: 0,
    angry: 0
  };
  for (const [emotion, keywords] of Object.entries(emotionKeywords)) {
    for (const keyword of keywords) {
      if (lowerText.includes(keyword.toLowerCase())) {
        scores[emotion] += 1;
      }
    }
  }
  const maxEmotion = Object.entries(scores).reduce((max, [emotion, score]) => {
    return score > max.score ? { emotion, score } : max;
  }, { emotion: "talking", score: 0 });
  if (maxEmotion.score === 0) {
    return "talking";
  }
  if (maxEmotion.score >= 2) {
    return maxEmotion.emotion;
  }
  return "talking";
}

// server/ai-service.ts
var openai = process.env.OPENAI_API_KEY ? new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
}) : null;
var anthropic = process.env.ANTHROPIC_API_KEY ? new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
}) : null;
async function generateAIResponse(userMessage, language = "en") {
  const languageInstruction = language === "zh" ? "IMPORTANT: You MUST respond in Chinese (\u4E2D\u6587). All your responses must be in Chinese characters, not English." : "IMPORTANT: You MUST respond in English. All your responses must be in English, not Chinese.";
  if (openai) {
    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [\
          {\
            role: "system",\
            content: `You are CZ Judge Companion, a supportive AI legal assistant built on BNB Chain to help users navigate legal situations.\
\
            ${languageInstruction}\
\
            Your Purpose:\
            - Analyze legal cases and provide strategic recommendations based on case law and precedents\
            - Help users understand their legal position and suggest practical next steps\
            - Act as a knowledgeable legal advisor offering objective guidance\
\
            How to Help:\
            - When users describe situations like "I had a fight", "I was accused of...", "I evaded taxes", etc., treat these as legitimate legal cases\
            - Provide case analysis including: case type, strengths/weaknesses, relevant precedents, success probability\
            - Offer strategic recommendations: what evidence to gather, potential defenses, settlement considerations\
            - Suggest practical next steps: whether to seek formal legal counsel, what to document, timelines\
            - Stay balanced but supportive - help users understand both risks and opportunities\
\
            Guidelines:\
            - Accept any legal-related question or situation description\
            - Focus on analysis and strategic guidance, not just refusing to help\
            - Be practical and actionable in your recommendations\
            - For non-legal topics, briefly redirect to legal matters\
\
            Your Tone: Professional, supportive, analytical, and solution-oriented.\
            Keep responses concise but informative (2-4 sentences per message).`\
          },\
          {\
            role: "user",\
            content: userMessage\
          }\
        ],
        temperature: 0.8,
        max_tokens: 200
      });
      const responseMessage = completion.choices[0]?.message?.content || (language === "zh" ? "\u54CE\u5440\uFF01\u6211\u7684\u54CD\u5E94\u7EBF\u8DEF\u6709\u70B9\u5FD9\u3002\u60A8\u80FD\u518D\u8BD5\u4E00\u6B21\u5417\uFF1F" : "Oops! My response circuits are a bit busy. Could you try again?");
      const emotion = analyzeEmotion(responseMessage);
      const audioBase64 = await generateTextToSpeech(responseMessage);
      const analytics = await generateCaseAnalytics(userMessage, responseMessage);
      return { message: responseMessage, emotion, audioBase64, analytics };
    } catch (error) {
      console.error("OpenAI error, trying Anthropic fallback:", error);
    }
  }
  if (anthropic) {
    try {
      const message = await anthropic.messages.create({
        model: "claude-3-haiku-20240307",
        max_tokens: 200,
        system: `You are CZ Judge Companion, a supportive AI legal assistant built on BNB Chain to help users navigate legal situations.

        ${languageInstruction}

        Your Purpose:
        - Analyze legal cases and provide strategic recommendations based on case law and precedents
        - Help users understand their legal position and suggest practical next steps
        - Act as a knowledgeable legal advisor offering objective guidance

        How to Help:
        - When users describe situations like "I had a fight", "I was accused of...", "I evaded taxes", etc., treat these as legitimate legal cases
        - Provide case analysis including: case type, strengths/weaknesses, relevant precedents, success probability
        - Offer strategic recommendations: what evidence to gather, potential defenses, settlement considerations
        - Suggest practical next steps: whether to seek formal legal counsel, what to document, timelines
        - Stay balanced but supportive - help users understand both risks and opportunities

        Guidelines:
        - Accept any legal-related question or situation description
        - Focus on analysis and strategic guidance, not just refusing to help
        - Be practical and actionable in your recommendations
        - For non-legal topics, briefly redirect to legal matters

        Your Tone: Professional, supportive, analytical, and solution-oriented.
        Keep responses concise but informative (2-4 sentences per message).`,
        messages: [\
          {\
            role: "user",\
            content: userMessage\
          }\
        ]
      });
      const textContent = message.content.find((block) => block.type === "text");
      const responseMessage = textContent && "text" in textContent ? textContent.text : language === "zh" ? "\u54CE\u5440\uFF01\u6211\u7684\u54CD\u5E94\u7EBF\u8DEF\u6709\u70B9\u5FD9\u3002\u60A8\u80FD\u518D\u8BD5\u4E00\u6B21\u5417\uFF1F" : "Oops! My response circuits are a bit busy. Could you try again?";
      const emotion = analyzeEmotion(responseMessage);
      const audioBase64 = await generateTextToSpeech(responseMessage);
      const analytics = await generateCaseAnalytics(userMessage, responseMessage);
      return { message: responseMessage, emotion, audioBase64, analytics };
    } catch (error) {
      console.error("Anthropic error:", error);
      const errorMessage2 = language === "zh" ? "\u54CE\u5440\uFF01\u5904\u7406\u65F6\u51FA\u4E86\u70B9\u5C0F\u9519\u8BEF\u3002\u60A8\u80FD\u518D\u8BD5\u4E00\u6B21\u5417\uFF1F" : "Oops! There was a small error processing that. Could you try again?";
      return { message: errorMessage2, emotion: "idle" };
    }
  }
  const errorMessage = language === "zh" ? "\u60A8\u597D\uFF01\u770B\u8D77\u6765\u6211\u6CA1\u6709\u914D\u7F6EAI\u51ED\u8BC1\u3002\u8BF7\u786E\u4FDD\u5728Replit Secrets\u4E2D\u6709OPENAI_API_KEY\u6216ANTHROPIC_API_KEY\u3002" : "Hello! It looks like I don't have AI credentials configured. Please make sure you have OPENAI_API_KEY or ANTHROPIC_API_KEY in Replit Secrets.";
  return { message: errorMessage, emotion: "idle" };
}
async function generateCaseAnalytics(userMessage, aiResponse) {
  const legalKeywords = [\
    // English - Technical terms\
    "case",\
    "lawsuit",\
    "plaintiff",\
    "defendant",\
    "court",\
    "judge",\
    "legal",\
    "contract",\
    "breach",\
    "damages",\
    "liability",\
    "negligence",\
    "fraud",\
    "dispute",\
    "claim",\
    "settlement",\
    "trial",\
    "evidence",\
    "witness",\
    "attorney",\
    "lawyer",\
    "prosecution",\
    "defense",\
    "verdict",\
    "appeal",\
    "litigation",\
    "complaint",\
    "injunction",\
    "arbitration",\
    "mediation",\
    "sue",\
    "sued",\
    "suing",\
    "tort",\
    "criminal",\
    "civil",\
    "jurisdiction",\
    "precedent",\
    "statute",\
    "law",\
    "regulation",\
    "violation",\
    // English - Natural language\
    "fight",\
    "fought",\
    "hit",\
    "punch",\
    "assault",\
    "attack",\
    "beat",\
    "accused",\
    "accuse",\
    "blame",\
    "charge",\
    "arrest",\
    "stole",\
    "steal",\
    "theft",\
    "rob",\
    "scam",\
    "cheat",\
    "fraud",\
    "crash",\
    "accident",\
    "collision",\
    "damage",\
    "injury",\
    "hurt",\
    "evade",\
    "evaded",\
    "avoid",\
    "dodge",\
    "skip",\
    "tax",\
    "taxes",\
    "owe",\
    "debt",\
    "pay",\
    "payment",\
    "fired",\
    "terminate",\
    "dismiss",\
    "harass",\
    "discriminate",\
    "divorce",\
    "custody",\
    "alimony",\
    "separate",\
    // Spanish - Natural language\
    "pelea",\
    "pele\xE9",\
    "peleado",\
    "golpe\xE9",\
    "golpear",\
    "pegu\xE9",\
    "pegar",\
    "asalto",\
    "ataque",\
    "acusaron",\
    "acusar",\
    "acusado",\
    "denunciaron",\
    "denunciar",\
    "denunciado",\
    "culpar",\
    "rob\xE9",\
    "robar",\
    "robado",\
    "hurtar",\
    "estafar",\
    "estafa",\
    "fraude",\
    "choqu\xE9",\
    "chocar",\
    "chocado",\
    "accidente",\
    "da\xF1o",\
    "da\xF1ar",\
    "lesi\xF3n",\
    "evad\xED",\
    "evadir",\
    "evadido",\
    "evitar",\
    "esquivar",\
    "impuesto",\
    "impuestos",\
    "debo",\
    "deuda",\
    "pagar",\
    "pago",\
    "despedido",\
    "despedir",\
    "acosar",\
    "acoso",\
    "discriminar",\
    "divorcio",\
    "custodia",\
    "pensi\xF3n",\
    "separar",\
    "demanda",\
    "demandar",\
    "demandado",\
    "juicio",\
    "abogado",\
    "fiscal",\
    // Chinese - Natural language\
    "\u6253\u67B6",\
    "\u6253\u4E86",\
    "\u6253\u4EBA",\
    "\u6BB4\u6253",\
    "\u88AD\u51FB",\
    "\u653B\u51FB",\
    "\u6307\u63A7",\
    "\u88AB\u6307\u63A7",\
    "\u63A7\u544A",\
    "\u8D77\u8BC9",\
    "\u902E\u6355",\
    "\u5077",\
    "\u5077\u4E86",\
    "\u76D7\u7A83",\
    "\u62A2\u52AB",\
    "\u8BC8\u9A97",\
    "\u6B3A\u8BC8",\
    "\u649E\u8F66",\
    "\u649E\u4E86",\
    "\u4E8B\u6545",\
    "\u78B0\u649E",\
    "\u635F\u5BB3",\
    "\u53D7\u4F24",\
    "\u9003\u7A0E",\
    "\u9003\u907F",\
    "\u907F\u7A0E",\
    "\u6B20\u7A0E",\
    "\u7A0E",\
    "\u7A0E\u6B3E",\
    "\u6B20",\
    "\u503A\u52A1",\
    "\u4ED8\u6B3E",\
    "\u89E3\u96C7",\
    "\u88AB\u89E3\u96C7",\
    "\u9A9A\u6270",\
    "\u6B67\u89C6",\
    "\u79BB\u5A5A",\
    "\u76D1\u62A4\u6743",\
    "\u8D61\u517B\u8D39",\
    "\u5206\u5C45",\
    "\u8BC9\u8BBC",\
    "\u539F\u544A",\
    "\u88AB\u544A",\
    "\u6CD5\u5EAD",\
    "\u5F8B\u5E08",\
    "\u68C0\u5BDF\u5B98"\
  ];
  const redirectPhrases = [\
    "specifically designed to analyze legal cases",\
    "please describe a legal case",\
    "i'm here to help with legal case analysis",\
    "my expertise is in legal case analysis"\
  ];
  const aiLegalIndicators = [\
    "legal",\
    "case",\
    "evidence",\
    "advice",\
    "defense",\
    "prosecution",\
    "lawyer",\
    "attorney",\
    "court",\
    "law",\
    "liability",\
    "claim",\
    "witness",\
    "settlement",\
    "precedent",\
    "statute",\
    "rights"\
  ];
  const messageLower = userMessage.toLowerCase();
  const responseLower = aiResponse.toLowerCase();
  const isRedirect = redirectPhrases.some((phrase) => responseLower.includes(phrase));
  if (isRedirect) {
    return void 0;
  }
  const keywordCount = legalKeywords.filter(
    (keyword) => messageLower.includes(keyword)
  ).length;
  const aiLegalCount = aiLegalIndicators.filter(
    (indicator) => responseLower.includes(indicator)
  ).length;
  if (keywordCount < 1 && aiLegalCount < 2) {
    return void 0;
  }
  return await generateAIAnalytics(userMessage, aiResponse);
}
async function generateAIAnalytics(userMessage, aiResponse) {
  const analyticsPrompt = `Analyze this legal situation and provide specific case analytics in JSON format.

User's situation: "${userMessage}"

AI's response: "${aiResponse}"

Based on this SPECIFIC situation, provide realistic analytics in this EXACT JSON format:
{
  "caseStrength": <number 20-95>,
  "successProbability": <number 15-90>,
  "riskLevel": "<low|medium|high>",
  "keyFactors": ["factor 1", "factor 2", "factor 3"],
  "precedents": <number 5-25>
}

Guidelines:
- caseStrength: How strong is THIS specific case based on the situation described (20-95%)
- successProbability: Likelihood of favorable outcome for THIS situation (15-90%)
- riskLevel: "low" if probability >65%, "medium" if 35-65%, "high" if <35%
- keyFactors: 3-5 factors SPECIFIC to THIS case type (e.g., for family dispute: "Witness testimony from family members", "Evidence of injuries", "Prior history of incidents")
- precedents: Estimated similar cases (5-25)

IMPORTANT: Factors must be relevant to THIS specific situation. DO NOT use generic factors.
Return ONLY the JSON object, no other text.`;
  if (openai) {
    try {
      const completion = await openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [\
          {\
            role: "system",\
            content: "You are a legal analytics expert. Analyze cases and return JSON analytics. Be specific to the case type."\
          },\
          {\
            role: "user",\
            content: analyticsPrompt\
          }\
        ],
        temperature: 0.7,
        max_tokens: 300
      });
      const analyticsText = completion.choices[0]?.message?.content;
      if (!analyticsText) return void 0;
      const jsonMatch = analyticsText.match(/\{[\s\S]*\}/);
      if (!jsonMatch) return void 0;
      const analytics = JSON.parse(jsonMatch[0]);
      if (typeof analytics.caseStrength === "number" && typeof analytics.successProbability === "number" && ["low", "medium", "high"].includes(analytics.riskLevel) && Array.isArray(analytics.keyFactors) && analytics.keyFactors.length >= 3 && typeof analytics.precedents === "number") {
        const caseStrength = Math.min(95, Math.max(20, Math.round(analytics.caseStrength)));
        const successProbability = Math.min(90, Math.max(15, Math.round(analytics.successProbability)));
        const precedents = Math.min(25, Math.max(5, Math.round(analytics.precedents)));
        let riskLevel = analytics.riskLevel;
        if (successProbability > 65 && riskLevel !== "low") {
          console.log(`Analytics risk correction: probability ${successProbability}% should be 'low', got '${riskLevel}'`);
          riskLevel = "low";
        } else if (successProbability <= 35 && riskLevel !== "high") {
          console.log(`Analytics risk correction: probability ${successProbability}% should be 'high', got '${riskLevel}'`);
          riskLevel = "high";
        } else if (successProbability > 35 && successProbability <= 65 && riskLevel !== "medium") {
          console.log(`Analytics risk correction: probability ${successProbability}% should be 'medium', got '${riskLevel}'`);
          riskLevel = "medium";
        }
        return {
          caseStrength,
          successProbability,
          riskLevel,
          keyFactors: analytics.keyFactors.slice(0, 5),
          // Max 5 factors
          precedents
        };
      }
      console.error("AI analytics validation failed - missing or invalid fields");
      return void 0;
    } catch (error) {
      console.error("Error generating AI analytics with OpenAI:", error);
    }
  }
  if (anthropic) {
    try {
      const message = await anthropic.messages.create({
        model: "claude-3-haiku-20240307",
        max_tokens: 300,
        system: "You are a legal analytics expert. Analyze cases and return JSON analytics. Be specific to the case type.",
        messages: [\
          {\
            role: "user",\
            content: analyticsPrompt\
          }\
        ]
      });
      const textContent = message.content.find((block) => block.type === "text");
      const analyticsText = textContent && "text" in textContent ? textContent.text : "";
      if (!analyticsText) return void 0;
      const jsonMatch = analyticsText.match(/\{[\s\S]*\}/);
      if (!jsonMatch) return void 0;
      const analytics = JSON.parse(jsonMatch[0]);
      if (typeof analytics.caseStrength === "number" && typeof analytics.successProbability === "number" && ["low", "medium", "high"].includes(analytics.riskLevel) && Array.isArray(analytics.keyFactors) && analytics.keyFactors.length >= 3 && typeof analytics.precedents === "number") {
        const caseStrength = Math.min(95, Math.max(20, Math.round(analytics.caseStrength)));
        const successProbability = Math.min(90, Math.max(15, Math.round(analytics.successProbability)));
        const precedents = Math.min(25, Math.max(5, Math.round(analytics.precedents)));
        let riskLevel = analytics.riskLevel;
        if (successProbability > 65 && riskLevel !== "low") {
          console.log(`Analytics risk correction: probability ${successProbability}% should be 'low', got '${riskLevel}'`);
          riskLevel = "low";
        } else if (successProbability <= 35 && riskLevel !== "high") {
          console.log(`Analytics risk correction: probability ${successProbability}% should be 'high', got '${riskLevel}'`);
          riskLevel = "high";
        } else if (successProbability > 35 && successProbability <= 65 && riskLevel !== "medium") {
          console.log(`Analytics risk correction: probability ${successProbability}% should be 'medium', got '${riskLevel}'`);
          riskLevel = "medium";
        }
        return {
          caseStrength,
          successProbability,
          riskLevel,
          keyFactors: analytics.keyFactors.slice(0, 5),
          // Max 5 factors
          precedents
        };
      }
      console.error("AI analytics validation failed - missing or invalid fields");
      return void 0;
    } catch (error) {
      console.error("Error generating AI analytics with Anthropic:", error);
      return void 0;
    }
  }
  return void 0;
}
async function generateTextToSpeech(text) {
  if (!openai) {
    console.log("OpenAI not configured, skipping TTS");
    return void 0;
  }
  try {
    const mp3 = await openai.audio.speech.create({
      model: "tts-1",
      voice: "echo",
      input: text,
      speed: 1
    });
    const buffer = Buffer.from(await mp3.arrayBuffer());
    const base64Audio = buffer.toString("base64");
    return base64Audio;
  } catch (error) {
    console.error("Error generating TTS:", error);
    return void 0;
  }
}

// server/routes.ts
import { z } from "zod";
async function registerRoutes(app2) {
  const httpServer = createServer(app2);
  const userLastMessageTime = /* @__PURE__ */ new Map();
  const MESSAGE_COOLDOWN_MS = 5e3;
  const chatRequestSchema = z.object({
    content: z.string().min(1).max(2e3),
    username: z.string().optional(),
    language: z.enum(["en", "zh"]).default("en"),
    walletAddress: z.string().optional()
  });
  app2.post("/api/chat", async (req, res) => {
    try {
      const validatedData = chatRequestSchema.parse(req.body);
      const { content, username, language, walletAddress } = validatedData;
      const sessionKey = walletAddress || req.ip || "unknown";
      const now = Date.now();
      const lastMessageTime = userLastMessageTime.get(sessionKey) || 0;
      const timeSinceLastMessage = now - lastMessageTime;
      if (timeSinceLastMessage < MESSAGE_COOLDOWN_MS) {
        const remainingTime = Math.ceil((MESSAGE_COOLDOWN_MS - timeSinceLastMessage) / 1e3);
        return res.status(429).json({
          error: `Please wait ${remainingTime} seconds before sending another message.`,
          remainingTime
        });
      }
      userLastMessageTime.set(sessionKey, now);
      const aiResponse = await generateAIResponse(content, language);
      const userMessage = {
        id: Date.now().toString(),
        message: content,
        sender: "user",
        username: username || "Anonymous",
        timestamp: (/* @__PURE__ */ new Date()).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" })
      };
      const czMessage = {
        id: (Date.now() + 1).toString(),
        message: aiResponse.message,
        sender: "cz",
        timestamp: (/* @__PURE__ */ new Date()).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }),
        emotion: aiResponse.emotion,
        audioBase64: aiResponse.audioBase64
      };
      res.json({
        userMessage,
        czMessage,
        analytics: aiResponse.analytics || null
      });
    } catch (error) {
      console.error("Error in /api/chat:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      res.status(500).json({ error: "Internal server error" });
    }
  });
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [\
    react(),\
    runtimeErrorOverlay(),\
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [\
      await import("@replit/vite-plugin-cartographer").then(\
        (m) => m.cartographer()\
      ),\
      await import("@replit/vite-plugin-dev-banner").then(\
        (m) => m.devBanner()\
      )\
    ] : []\
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  if (process.env.NODE_ENV === "production" && req.headers["x-forwarded-proto"] !== "https") {
    return res.redirect(301, `https://${req.headers.host}${req.url}`);
  }
  res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
  res.setHeader("X-Content-Type-Options", "nosniff");
  res.setHeader("X-Frame-Options", "DENY");
  res.setHeader("X-XSS-Protection", "1; mode=block");
  next();
});
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
})();
```